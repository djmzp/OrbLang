---
layout: default
title: Introduction
---
# {{ page.title }}

If you are here, you are likely interested in learning more about the Orb programming language. This document is written as a guide to writing code in Orb, and tries to explain all the possibilities you have when using this language. It will first go through the basics - concepts shared with many other languages (though they may work slightly differently in Orb), before moving on to more advanced and exciting techniques.

But first, a few words on Orb from a very high level.

From a technical standpoint, Orb can be thought of as a compiled, statically-typed, non-memory-managed language, with an intentionally limited core feature set.

There are actually two different, though similar, languages working together that comprise Orb. One is the language of compilations - code written in this language is what will be compiled into binary form. The other is the language of evaluations - code written in this language is executed by the Orb compiler, and controls what and how the first one compiles. What this means is that every run of the Orb compiler is, in a way, an execution of your code, whose output is the final executable file.

There are two goals for which Orb strives. On one side, it strives for simplicity, as the language should not contain any features the programmer may feel are out of place or they are being forced into using. On the other side, Orb strives to be open-ended, by allowing the programmer to extend the language whenever the need arises and allowing flexibility when using the existing features.

Ultimately, Orb is about control. You are in control of your code, its writing, compilation, and execution. Orb offers you a powerful set of tools for the job, but leaves all the decision-making to you.

When you are ready, click on the right arrow to start learning Orb.