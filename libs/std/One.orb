import "base.orb";
import "clib.orb";

mac std.getValTy (one::preprocess) {
    ret (attrOf (typeOf one) std.valTy);
};

eval (fnc std.One (valTy:type) type {
    sym (name (+ \std.One (cast id valTy)));

    if (! (?? ,name)) {
        data::global ,name {
            -p:(valTy *)
        }::((std.class std.One) (std.valTy ,valTy)) (fnc::global std.-dropOne::(compilable (evaluable false)) (this:,name::noDrop) () {
            if (!= ([] this -p) null) {
                >>::noZero (* ([] this -p));
            };
            free (cast ptr ([] this -p));
        });
    };

    ret (name);
});

mac std.makeOne (valTy::preprocess) {
    sym (oneTy (std.One valTy));

    ret \(block ,oneTy {
        sym x:,oneTy;
        = ([] x -p) (cast ,(valTy *) (calloc 1 ,(sizeOf valTy)));
        pass x;
    });
};

mac std.makeOneWith (val::preprocess) {
    sym (valTy (typeOf val));
    sym (oneTy (std.One valTy));

    ret \(block ,oneTy {
        sym x:,oneTy;
        = ([] x -p) (cast ,(valTy *) (malloc ,(sizeOf valTy)));
        = (* ([] x -p)) ,val;
        pass x;
    });
};

mac std.* (one::preprocess) {
    ret \(* ([] ,one -p));
};

mac std.-> (one::preprocess ind) {
    ret \([] (* ([] ,one -p)) ,ind);
};

mac std.isNull (one::preprocess) {
    ret \(== ([] ,one -p) null);
};

mac std.getPtr (one::preprocess) {
    ret \(unref ([] ,one -p));
};