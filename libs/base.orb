# TODO detect errors in invocations

eval (sym (base.-genSymToken 0:u64));

eval (fnc genSym () id {
    sym (s (+ \base.-genSym (cast id base.-genSymToken)));
    = base.-genSymToken (+ base.-genSymToken 1);
    ret s;
});

mac base.-passthrough (x::preprocess) {
    ret x;
};

mac if (cond then) {
    ret \(block {
        (exit (! ,cond))
        (block ,then)
    });
};

mac if (cond then else) {
    ret \(block base.-blockIf () {
        (block {
            (exit (! ,cond))
            (block ,then)
            (exit base.-blockIf true)
        })
        (block ,else)
    });
};

mac while (cond body) {
    ret \(block base.-blockLoop () {
        (block base.-blockLoopInner () {
            (exit base.-blockLoop (! ,cond))
            (block ,body)
        })
        (loop true)
    });
};

mac for (init cond step body) {
    ret \(block base.-blockLoop () {
        ,init
        (block {
            (block base.-blockLoopInner () {
                (exit base.-blockLoop (! ,cond))
                (block ,body)
            })
            ,step
            (loop true)
        })
    });
};

mac break () {
    ret \(exit base.-blockLoop true);
};

mac continue () {
    ret \(exit base.-blockLoopInner true);
};

mac range (i up::preprocess body) {
    ret \(for (sym (,i 0:(typeOf up))) (< ,i ,up) (= ,i (+ ,i 1)) ,body);
};

mac rangeRev (i up::preprocess body) {
    sym (s (genSym));

    ret \(range ,s ,up {
        (sym (,i (- ,up 1 ,s)))
        (block ,body)
    });
};

mac range (i lo::preprocess hi::preprocess body) {
    ret \(for (sym (,i ,lo)) (<= ,i ,hi) (= ,i (+ ,i 1)) ,body);
};

mac rangeRev (i hi::preprocess lo::preprocess body) {
    sym (s (genSym));

    ret \(range ,s ,lo ,hi {
        (sym (,i (+ ,lo (- ,hi ,s))))
        (block ,body)
    });
};

mac repeat (n::preprocess body) {
    sym (s (genSym));
    ret \(range ,s ,n ,body);
};

mac ++ (x::preprocess) {
    ret \(= ,x (+ ,x 1));
};

mac -- (x::preprocess) {
    ret \(= ,x (- ,x 1));
};

mac ?_ (cond::preprocess ty::preprocess onTrue onFalse) {
    ret \(block base.-blockTernSel ,ty {
        (if ,cond {
            (pass base.-blockTernSel ,onTrue)
        })
        (pass ,onFalse)
    });
};

# Not intended for use on raw.
mac += (x::preprocess y::preprocess) {
    ret \(= ,x (+ ,x ,y));
};

mac -= (x::preprocess y::preprocess) {
    ret \(= ,x (- ,x ,y));
};

mac *= (x::preprocess y::preprocess) {
    ret \(= ,x (* ,x ,y));
};

mac /= (x::preprocess y::preprocess) {
    ret \(= ,x (/ ,x ,y));
};

mac %= (x::preprocess y::preprocess) {
    ret \(= ,x (% ,x ,y));
};

mac <<= (x::preprocess y::preprocess) {
    ret \(= ,x (<< ,x ,y));
};

mac >>= (x::preprocess y::preprocess) {
    ret \(= ,x (>> ,x ,y));
};

mac &= (x::preprocess y::preprocess) {
    ret \(= ,x (& ,x ,y));
};

mac |= (x::preprocess y::preprocess) {
    ret \(= ,x (| ,x ,y));
};

mac ^= (x::preprocess y::preprocess) {
    ret \(= ,x (^ ,x ,y));
};

mac -> (x::preprocess m rest::variadic) {
    sym (ops (+ \(,x ,m) rest));

    sym (code \(base.-passthrough ,(. ops 0)));
    range i 1 (- (lenOf ops) 1) {
        = code \(. (* ,code) ,(. ops i));
    };

    ret code;
};

mac && (a b rest::variadic) {
    sym (ops (+ \(,a ,b) rest));

    sym (innerCode {});
    range i (lenOf ops) {
        = innerCode (+ innerCode \{
            (block {
                (exit ,(. ops i))
                (pass base.-blockLogAnd false)
            })});
    };
    = innerCode (+ innerCode \{ (pass true) });

    ret \(block base.-blockLogAnd bool ,innerCode);
};

mac || (a b rest::variadic) {
    sym (ops (+ \(,a ,b) rest));

    sym (innerCode {});
    range i (lenOf ops) {
        = innerCode (+ innerCode \{
            (block {
                (exit (! ,(. ops i)))
                (pass base.-blockLogAnd true)
            })});
    };
    = innerCode (+ innerCode \{ (pass false) });

    ret \(block base.-blockLogAnd bool ,innerCode);
};

mac arr (ty::preprocess a::preprocess rest::(variadic preprocess)) {
    sym (elems (+ \(,a) rest));
    sym (arrTy (ty (lenOf elems)));

    # genSym not needed since only visible in inner code, and elements are preprocessed
    sym (innerCode \{ (sym res:arrTy) });
    range i (lenOf elems) {
        = innerCode (+ innerCode \{ (= ([] res ,i) ,(. elems i)) });
    };
    = innerCode (+ innerCode \{ (pass res) });

    ret \(block ,arrTy ,innerCode);
};

mac base.-tupType (a::preprocess b::preprocess rest::preprocess) {
    sym (res \(,(typeOf a) ,(typeOf b)));

    range i (lenOf rest) {
        = res (+ res \(,(typeOf (. rest i))));
    };

    ret res;
};

mac tup (a::preprocess b::preprocess rest::(variadic preprocess)) {
    sym (membs (+ \(,a ,b) rest));
    sym (tupTy (base.-tupType a b rest));

    # genSym not needed since only visible in inner code, and members are preprocessed
    sym (innerCode \{ (sym res:tupTy) });
    range i (lenOf membs) {
        = innerCode (+ innerCode \{ (= (. res ,i) ,(. membs i)) });
    };
    = innerCode (+ innerCode \{ (pass res) });

    ret \(block ,tupTy ,innerCode);
};

mac make (ty::preprocess pair rest::variadic) {
    sym (pairs (+ \(,pair) rest));
    sym (inst (genSym));

    sym (innerCode \{ (sym ,inst:ty) });
    range i (lenOf pairs) {
        # ensure it's raw
        cast raw (. pairs i);

        = innerCode (+ innerCode \{ (= (. ,inst ,(. pairs i 0)) ,(. pairs i 1)) });
    };
    = innerCode (+ innerCode \{ (pass ,inst) });

    ret \(block ,ty ,innerCode);
};
