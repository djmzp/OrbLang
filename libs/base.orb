eval (sym (base.-genSymToken 0:u64));

eval (fnc genSym () id {
    sym (s (+ \base.-genSym (cast id base.-genSymToken)));
    = base.-genSymToken (+ base.-genSymToken 1);
    ret s;
});

mac passthrough (x::preprocess) {
    ret x;
};

mac base.isRaw (x::preprocess) {
    block {
        exit (!= (typeOf x) raw);
        ret true;
    };
    block {
        exit (!= (typeOf x) (raw cn));
        ret true;
    };
    ret false;
};

mac if (cond then) {
    ret \(block {
        (exit (! ,cond))
        (block ,then)
    });
};

mac if (cond then restFirst rest::variadic) {
    sym (args (+ \(,cond ,then ,restFirst) rest));

    sym (innerCode {});
    range i 0 (- (lenOf args) 2) 2 {
        = innerCode (+ innerCode \{
            (block {
                (exit (! ,(. args i)))
                (block ,(. args (+ i 1)))
                (exit base.-blockIf true)
            })
        });
    };

    block {
        exit (== (% (lenOf args) 2) 0);
        = innerCode (+ innerCode \{
            (block ,(. args (- (lenOf args) 1)))
        });
    };

    ret \(block base.-blockIf () ,innerCode);
};

mac while (cond body) {
    ret \(block base.-blockLoop () {
        (block base.-blockLoopInner () {
            (exit base.-blockLoop (! ,cond))
            (block ,body)
        })
        (loop true)
    });
};

mac for (init cond step body) {
    ret \(block base.-blockLoop () {
        ,init
        (block {
            (block base.-blockLoopInner () {
                (exit base.-blockLoop (! ,cond))
                (block ,body)
            })
            ,step
            (loop true)
        })
    });
};

mac break () {
    ret \(exit base.-blockLoop true);
};

mac continue () {
    ret \(exit base.-blockLoopInner true);
};

mac range (i up::preprocess body) {
    ret \(for (sym (,i 0:(typeOf up))) (< ,i ,up) (= ,i (+ ,i 1)) ,body);
};

mac rangeRev (i up::preprocess body) {
    sym (s (genSym));

    ret \(range ,s ,up {
        (sym (,i (- ,up 1 ,s)))
        (block ,body)
    });
};

mac range (i lo::preprocess hi::preprocess body) {
    ret \(for (sym (,i ,lo)) (<= ,i ,hi) (= ,i (+ ,i 1)) ,body);
};

mac rangeRev (i hi::preprocess lo::preprocess body) {
    sym (s (genSym));

    ret \(range ,s ,lo ,hi {
        (sym (,i (+ ,lo (- ,hi ,s))))
        (block ,body)
    });
};

mac range (i lo::preprocess hi::preprocess delta::preprocess body) {
    ret \(for (sym (,i ,lo)) (<= ,i ,hi) (= ,i (+ ,i ,delta)) ,body);
};

mac rangeRev (i hi::preprocess lo::preprocess delta::preprocess body) {
    sym (s (genSym));

    ret \(range ,s ,lo ,hi ,delta {
        (sym (,i (+ ,lo (- ,hi ,s))))
        (block ,body)
    });
};

mac repeat (n::preprocess body) {
    sym (s (genSym));
    ret \(range ,s ,n ,body);
};

mac ++ (x::preprocess) {
    ret \(= ,x (+ ,x 1));
};

mac -- (x::preprocess) {
    ret \(= ,x (- ,x 1));
};

mac ?_ (cond::preprocess ty::preprocess onTrue onFalse) {
    ret \(block base.-blockTernSel ,ty {
        (if ,cond {
            (pass base.-blockTernSel ,onTrue)
        })
        (pass ,onFalse)
    });
};

# Not intended for use on raw.
mac += (x::preprocess y::preprocess) {
    ret \(= ,x (+ ,x ,y));
};

mac -= (x::preprocess y::preprocess) {
    ret \(= ,x (- ,x ,y));
};

mac *= (x::preprocess y::preprocess) {
    ret \(= ,x (* ,x ,y));
};

mac /= (x::preprocess y::preprocess) {
    ret \(= ,x (/ ,x ,y));
};

mac %= (x::preprocess y::preprocess) {
    ret \(= ,x (% ,x ,y));
};

mac <<= (x::preprocess y::preprocess) {
    ret \(= ,x (<< ,x ,y));
};

mac >>= (x::preprocess y::preprocess) {
    ret \(= ,x (>> ,x ,y));
};

mac &= (x::preprocess y::preprocess) {
    ret \(= ,x (& ,x ,y));
};

mac |= (x::preprocess y::preprocess) {
    ret \(= ,x (| ,x ,y));
};

mac ^= (x::preprocess y::preprocess) {
    ret \(= ,x (^ ,x ,y));
};

mac -> (x::preprocess m rest::variadic) {
    sym (ops (+ \(,x ,m) rest));

    sym (code \(passthrough ,(. ops 0)));
    range i 1 (- (lenOf ops) 1) {
        = code \(. (* ,code) ,(. ops i));
    };

    ret code;
};

mac && (a b rest::variadic) {
    sym (ops (+ \(,a ,b) rest));

    sym (innerCode {});
    range i (lenOf ops) {
        = innerCode (+ innerCode \{
            (block {
                (exit ,(. ops i))
                (pass base.-blockLogAnd false)
            })});
    };
    = innerCode (+ innerCode \{ (pass true) });

    ret \(block base.-blockLogAnd bool ,innerCode);
};

mac || (a b rest::variadic) {
    sym (ops (+ \(,a ,b) rest));

    sym (innerCode {});
    range i (lenOf ops) {
        = innerCode (+ innerCode \{
            (block {
                (exit (! ,(. ops i)))
                (pass base.-blockLogAnd true)
            })});
    };
    = innerCode (+ innerCode \{ (pass false) });

    ret \(block base.-blockLogAnd bool ,innerCode);
};

mac alias (name ty) {
    ret \(eval (sym (,name:(type cn) ,ty)));
};

mac arr (ty::preprocess a::preprocess rest::(variadic preprocess)) {
    sym (elems (+ \(,a) rest));
    sym (arrTy (ty (lenOf elems)));

    # genSym not needed since only visible in inner code, and elements are preprocessed
    sym (innerCode \{ (sym res:arrTy) });
    range i (lenOf elems) {
        = innerCode (+ innerCode \{ (= ([] res ,i) ,(. elems i)) });
    };
    = innerCode (+ innerCode \{ (pass res) });

    ret \(block ,arrTy ,innerCode);
};

mac base.-tupType (a::preprocess b::preprocess rest::preprocess) {
    sym (res \(,(typeOf a) ,(typeOf b)));

    range i (lenOf rest) {
        = res (+ res \(,(typeOf (. rest i))));
    };

    ret res;
};

mac tup (a::preprocess b::preprocess rest::(variadic preprocess)) {
    sym (membs (+ \(,a ,b) rest));
    sym (tupTy (base.-tupType a b rest));

    # genSym not needed since only visible in inner code, and members are preprocessed
    sym (innerCode \{ (sym res:tupTy) });
    range i (lenOf membs) {
        = innerCode (+ innerCode \{ (= (. res ,i) ,(. membs i)) });
    };
    = innerCode (+ innerCode \{ (pass res) });

    ret \(block ,tupTy ,innerCode);
};

mac base.-makeErrorEntryLen (entry) {
    ret \(message::(error (loc entry)) "Each entry must contain exactly two values - member name and initial value.");
};

mac make (ty::preprocess pair rest::variadic) {
    sym (pairs (+ \(,pair) rest));
    sym (inst (genSym));

    sym (innerCode \{ (sym ,inst:ty) });
    range i (lenOf pairs) {
        cast raw (. pairs i);

        if (!= (lenOf (. pairs i)) 2) {
            ret \(base.-makeErrorEntryLen ,(. pairs i));
        };

        = innerCode (+ innerCode \{ (= (. ,inst ,(. pairs i 0)) ,(. pairs i 1)) });
    };
    = innerCode (+ innerCode \{ (pass ,inst) });

    ret \(block ,ty ,innerCode);
};

mac lam (body) {
    ret \(fnc::global ,(genSym) () () ,body);
};

mac lam (retTy::preprocess body) {
    ret \(fnc::global ,(genSym) () ,retTy ,body);
};

mac lam (args retTy::preprocess body) {
    ret \(fnc::global ,(genSym) ,args ,retTy ,body);
};

mac pat (body) {
    ret \(mac::global ,(genSym) () ,body);
};

mac pat (args body) {
    ret \(mac::global ,(genSym) ,args ,body);
};

mac base.-enumTypeDecl (name ty) {
    ret \(fixed ,name ,ty);
};

eval (fnc base.-enumValName (enumName:id valName:id) id {
    ret (+::bare enumName \. valName);
});

mac base.-enumErrorEntryLen (entry) {
    ret \(message::(error (loc entry)) "Each entry must be either an id or have exactly two values - name and initial value.");
};

mac base.-enumValsDecl (name vals) {
    sym (code \(sym));

    sym valName:id valNamePrev:id init:raw;
    range i (lenOf vals) {
        if (base.isRaw (. vals i)) {
            if (!= (lenOf (. vals i)) 2) {
                ret \(base.-enumErrorEntryLen ,(. vals i));
            };

            cast id (. vals i 0);
            = valName (. vals i 0);

            = init \(cast ,name ,(. vals i 1));
        } {
            cast id (. vals i);
            = valName (. vals i);

            if (== i 0) {
                = init \(cast ,name 0);
            } {
                = init \(+ ,(base.-enumValName name valNamePrev) (cast ,name 1));
            };
        };

        = valNamePrev valName;

        = code (+ code
            \( (,(base.-enumValName name valName) ,init) ));
    };

    ret code;
};

# TODO num of entries
mac enum (name ty::preprocess vals) {
    cast id name;
    cast type ty;
    cast raw vals;

    if (== (lenOf vals) 0) {
        message::(error (loc vals)) "Must specify at least one enum value.";
        ret ();
    };

    ret \(eval (block::bare {
        (base.-enumTypeDecl ,name ,ty)
        (base.-enumValsDecl ,name ,vals)
    }));
};

mac enum (name vals) {
    ret \(enum ,name ,i32 ,vals);
};