program ::= exprs;

exprs ::= expr exprs |
	eps;

expr ::= expr_walled |
	exprs ';';

expr_walled ::= expr_walled_bare |
	expr_walled_bare ':' expr_walled_bare |
	expr_walled_bare '::' expr_walled_bare |
	expr_walled_bare ':' expr_walled_bare '::' expr_walled_bare;

expr_walled_bare ::= '(' exprs ')' |
	'{' exprs '}' |
	'\' expr_walled_bare |
	',' expr_walled_bare |
	ID |
	INT |
	FLOAT |
	CHAR |
	STRING |
	BOOL |
	NULL;

_ALPHA is [a-zA-Z]
_DIGIT is [0-9]
_SIGNS is [=+-*/%<>&|^!~[]._?]
ID is [:_ALPHA::_DIGIT::SIGNS:]* that does not start with :_DIGIT: nor +:_DIGIT: nor -:_DIGIT:
INT and FLOAT are ([+-]?:_DIGIT:)[0123456789abcdefABCDEF.xXeEpP_]*
CHAR is within '', STRING is within ""
BOOL is true or false
NULL is null

\ increases escape score, , decreases it
if score is >0, considered to be escaped

comments are # for single line, #* ... *# for multiline

Char unescape sequences are: \', \", \?, \\, \a, \b, \f, \n, \r, \t, \v, \0, and \xNN (where N is a hex digit in [0-9a-fA-F]).

********************

class LiteralVal:
	literal stuff

class EvalVal:
	TypeTable::Id
	oneof:
		prim stuff
		id
		type
		repeated EvalVal
	optional ref

class LlvmVal:
	TypeTable::Id
	val
	ref

class NodeVal:
	CodeLoc
	oneof:
		LiteralVal
		EvalVal
		LlvmVal
	type node
	is import
	is invalid
	is valid

********************

processing leaf:
	if literal:
		promote to evalVal
	if id and not escaped:
		process as var
	else:
		unescape once
		return as is

processing non-leaf:
	if escaped:
		process all children
		return raw with escape score of 1 less
	process starting
	if starting is macro:
		invoke
		process new node
	else:
		depending on what starting is (id, type, function, keyword, oper), process as that

processing node:
	if empty or no children:
		process as leaf
	else:
		process as non-leaf

when promoting literal to evalVal, type attribute is respected as eval impl cast, unless id
	if escaped, escape score and type attribute preserved
compiler cannot gen type, id or raw vars, cannot gen code in global
evaluator can have pointers only be null, strings may be non-null or null

type attr
	:a
	if has attrs, type attr must precede

attrs
	::a OR ::(...[(a v) OR a])
	a is id
	a cannot be type (identifier)

sym
	sym a:t OR sym (a:t) OR sym (a b) OR sym (a:t b), variadic
	a is id, t is type, b is init value
	if a is leaf id, it is evaluated as that id
	b cast to t, if no t then a is type of b
	zero initialized (id to main, type to id, raw to empty)

cast
	cast t a

block
	block body OR block t body OR block name t body
	body is repeated instructions
	t is return type or () for no ret
	name is block name or () for no name
	if name is leaf id, it is evaluated as that id
	opens new scope, goes through body, closes scope
	if has ret type, expects value passed

exit
	exit cond OR exit name cond
	if name is leaf id, it is evaluated as that id
	exits a block if cond is true
	if name given, exits that block, otherwise innermost enclosing block
	has to be non-retting block

loop
	loop cond OR loop name cond
	if name is leaf id, it is evaluated as that id
	re-enters a block if cond is true, clearing scopes
	if name given, re-enters that block, otherwise innermost enclosing block

pass
	pass val OR pass name val
	if name is leaf id, it is evaluated as that id
	exits a block, yielding val as ret
	if name given, exits that block, otherwise innermost enclosing block
	has to be retting block

fnc
	fnc name args type OR fnc name args type body
	first declares, second defines a function
	if name is leaf id, it is evaluated as that id
	args is list of args as a:t, if a is leaf id, it is evaluated as that id
	type is ret type or no ret if it's ()
	fnc has its own scope, goes through body
	if retting, expects ret

mac
	mac name args subst
	if name is leaf id, it is evaluated as that id
	args is list of args, if any is leaf id, it is evaluated as that id
	invoked not evaluating its args, invocations repeteadly resolved until no longer macro invocation, after code processed normally
	when invoked, replaces invoke node with subst, but appearances of any arg replaced with passed node

ret
	ret OR ret val
	returns from function
	has to be in function

eval
	eval inst
	evaluates instruction

tup
	tup a ...b
	creates a tuple out of provided vals

typeOf
	typeOf val
	returns the type of val

lenOf
	lenOf val
	if val is a type:
		if val is a type arr, returns its length
		if val is a type tuple, returns its num of membs
		if val is a type raw, returns its num of children
		otherwise, error
	else:
		return lenOf its type
	returns a u64

sizeOf
	sizeOf val
	if val is a type:
		returns memory alloc size of val
	else:
		return sizeOf its type
	if not a compilable type, error
	returns a u64

??
	?? name
	returns whether a symbol with name is defined

attrOf
	attrOf val name
	gets name attr of val
	if name is type, gets type attr
	errors if no such attr

attr??
	attr?? val name
	returns whether val has name attr
	if name is type, returns whether it has type attr

import
	import a
	a is evalVal string
	orchestrator processes the file, then returns here
	rules about no cyclical dependencies, etc.
	// TODO import ...a

=
	= ...a
	r-assoc
	assigns val of right to left
	returns ref-val
	may cast right to left

+ - * / % & ^ | << >>
	op ...a
	calcs in pairs
	may cast left to right, on fail right to left
	+ - * & can be unary, others not
	^ not variadic

== != < <= > >=
	op a ...b
	compares in pairs (this means that (!= 1 2 1) gives true)
	breaks on first false and rets false, otherwise true

! ~
	op a

[] .
	op a ...b
	goes in pairs
	. works on pointers also
	for . if raw and member is not raw, non-ref returned

type
	type ...a
	if past first is leaf and not escaped, escape, then if id of type, get that type

********************

plan:
 - custom types (req attr in sym, type cn only)
 - variadics
 - first class fncs and macs
 - declarations (fncs and tuple types only)
 - ptrs in eval
 - drop, move
 - new attributes: noZero, noScope, inline, restrict, noDrop, unique, pure...
 - include C headers
