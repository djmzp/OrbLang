import "util/base.orb";
import "util/io.orb";

fnc foo() () {
    println_i64 10;
};

fnc bar() () {
    for () true () { ret; };
};

fnc loneRet() () {
    ret ();
};

fnc inc(a:i64) i64 {
    ret (+ a 1);
};

fnc blocker() i64 {
    while true;
    for () true ();
    ret 0;
};

fnc sameNamed(sameNamed:i32) () {
    println_i32 sameNamed;
};

// TODO test of loop evaluation after implementing evaluation of sym (+ maybe more exit tests)
sym (glob1
        (block i32 { pass 500; }))
    (glob2
        (block block1 i32 {
            if (> 1 2)
                { pass block1 -1; }
                { pass block1 501; };
            pass block1 -1;
        }))
    (glob3
        (block block1 i32 {
            loop (block bool { pass block1 502; pass true; });
            pass -1;
        }))
    (glob4
        (block block1 i32 {
            block {
                exit true;
                pass block1 -1;
            };
            pass 503;
        }));

fnc main() () {
    sym (a:i64 1) (b 2:i64);
    if (== a b) {(println_i64 101)};
    if (< a b) {(println_i64 102)};
    if (>= a b) {(println_i64 103)};
    if (> (+ a 3) (+ b 5)) {(println_i64 104)};
    block () {
        sym (x:i64 5);
        if (> x a) { (println_i64 105) };
    };
    block blockName () {
        = a 100;
        if (> a b) { (println_i64 106) };
    };

    = a 1;
    = b 2;
    if (< a b)
        {(println_i64 107)}
        {(println_i64 108)};
    if (== a b)
        {(println_i64 109)}
        {(println_i64 110)};
    if (== (/ a b) 1)
        {(println_i64 111)}
        {(if (== (* a b) 1)
            {(println_i64 112)}
            {(println_i64 113)})};
    if (== (+ a b) 3) {
        (println_i64 114)
        (if (== (% a b) 1) {
            (println_i64 115)
        } {
            (println_i64 116)
        })
    };

    for (sym (i:i64 0) (j:i64 (- 1))) (< i 10) (++ i) {(println_i64 (+ i j))};
    for (= a 0) (< a 3) (++ a) {(println_i64 a)};
    for () (>= a 0) (-- a) {(println_i64 a)};
    for (sym (i:i32 10)) (> i 0) (-- i);

    while (>= b 0) {(println_i64 (-- b))};
    do {
        sym (x:i64 2);
        println_i64 b;
        = b (+ b x);
    } (< (+ b a) 8);
    do {println_i64 1;} (>= (-- a) 0);
    do {} (> a 0);

    bar;

    for (sym (i:i32 0)) (< i 10) (++ i) {
        break (>= i 3);
        println_i32 i;
    };

    while (<= a 0) {
        break (<= a (- 3));
        println_i64 a;
        -- a;
    };

    do {
        break (== a 0);
        println_i64 a;
        = a 0;
    } (< a 1);

    for (sym (i:i32 0)) (< i 10) (++ i) {
        continue (>= i 2);
        println_i32 i;
    };

    while (<= a 0) {
        ++ a;
        continue (> a 0);
        println_i64 a;
    };

    = a 99;
    do {
        continue (== a 0);
        println_i64 a;
        = a 0;
    } (!= a 0);

    for (sym (i:i32 0)) (< i 2) (++ i) {
        println_i32 i;
        for (sym (j:i32 0)) (< j 5) (++ j) {
            println_i32 j;
            break (>= j 1);
        };
    };

    for (sym (i:i32 0)) (> i (- 2)) (-- i) {
        println_i32 i;
        for (sym (j:i32 0)) (> j (- 5)) (-- j) {
            continue (<= j (- 1));
            println_i32 j;
        };
    };

    for (sym (i:i32 10)) (< i 15) (++ i) {
        println_i32 i;
        break (>= i 11);
        for (sym (j:i32 10)) (< j 12) (++ j) {
            println_i32 j;
        };
    };

    for (sym (i:i32 (- 10))) (> i (- 13)) (-- i) {
        println_i32 i;
        continue (<= i (- 11));
        for (sym (j:i32 (- 10))) (> j (- 12)) (-- j) {
            println_i32 j;
        };
    };

    println_i64 (inc b);
    println_i64 (+ (inc b) 1);

    if (> 1 0) {(println_i64 0)} {(println_i64 (blocker))};
    if (< 1 0) {(println_i64 (blocker))} {(println_i64 0)};

    if (and false (== (blocker) 0)) {(println_i32 0)};
    if (or true (== (blocker) 0)) {(println_i32 0)};

    sym (bar:i32 200);
    println_i32 bar;

    sameNamed 201;

    while false {
        continue false;
    };

    while true {
        break true;
    };

    while true {
        break (> 2 1);
    };

    while false {
        sym (x:i32 1);
        continue (> x 2);
    };

    block block1 () {
        while true {
            println_i32 202;
            exit block1 true;
        };
        println_i32 203;
    };

    println_i32 (block i32 {
        sym (x 300);
        pass x;
    });

    println_i32 (block block1 i32 {
        block {
            sym (x:i16 301);
            pass block1 x;
        };
        pass 0; // dummy TODO make this unnecessary
    });

    block block1 () {
        println_i32 302;
        block i32 {
            exit block1 true;
            pass 0; // dummy
        };
        println_i32 303;
    };

    println_i32 (block block1 i32 {
        sym (x:bool true);
        block () {
            exit x;
            pass block1 304;
        };
        block {
            exit (! x);
            pass block1 305;
        };
        pass 0; // dummy
    });

    loneRet;

    block block1 () {
        sym x:i32;
        block block2 () {
            // TODO make the same test for evaluation of block
            + (= x 400) (block i32 { exit block2 true; = x -1; pass 0; }) (= x -1);
        };
        println_i32 x;
    };

    block block1 () {
        println_i32 401;
        loop (block bool { exit block1 true; pass true; });
    };

    println_i32 glob1;
    println_i32 glob2;
    println_i32 glob3;
    println_i32 glob4;
};