import "tests/io.orb";

fnc pair(x:i32 y:i32) (i32 i32) {
    let r:(i32 i32);
    = (. r 0) x;
    = (. r 1) y;
    ret r;
};

fnc dot(x:(i32 i32) y:i32) i32 {
    if (== y 0) {
        ret (. x 0);
    };
    if (== y 1) {
        ret (. x 1);
    };
    ret -1;
};

fnc copy(x:((i32 i32) *)) (i32 i32) {
    let r:(i32 i32);
    = (. r 0) (. x 0);
    = (. r 1) (. x 1);
    ret r;
};

fnc addCn(x:(i32 i32)) ((i32 cn) (i32 cn)) {
    ret (* (cast (((i32 cn) (i32 cn)) *) (& x)));
};

fnc remCn(x:((i32 cn) (i32 cn))) (i32 i32) {
    ret (* (cast (((i32) (i32)) *) (& x)));
};

let glob1:(i32 i32);

fnc main() () {
    block {
        let x:(i32 bool);
        = (. x 0) 100;
        = (. x 1) true;
        if (. x 1) {
            println_i32 (. x 0);
        };
    };
    block {
        let x:(i32 bool);
        let y:(i32 bool);
        = (. x 0) 200;
        = (. y 0) (. x 0);
        println_i32 (. y 0);
    };
    block {
        let x:((i32 f32) bool);
        = (. (. x 0) 0) 300;
        println_i32 (. (. x 0) 0);
    };
    block {
        let x:((i32 i32) 4);
        = (. ([] x 0) 0) 400;
        println_i32 (. ([] x 0) 0);
    };
    block {
        let x:(i32 i32);
        let y:((i32 i32) *);
        = y (& x);
        = (. x 0) 500;
        println_i32 (. (* y) 0);
    };
    block {
        let x:(i32 i32);
        let y:(i32 []);
        = y (cast (i32 []) (& x));
        = (. x 0) 600;
        println_i32 ([] y 0);
    };
    block {
        let x:((i32 i32) 4);
        let (y:(i32 []) (cast (i32 []) (& x)));
        = (. ([] x 0) 0) 700;
        = (. ([] x 0) 1) 701;
        = (. ([] x 1) 0) 702;
        println_i32 ([] y 0);
        println_i32 ([] y 1);
        println_i32 ([] y 2);
    };
    block {
        let (x:i32 800) (y:i32 801);
        let (z:(i32 i32) (pair x y));
        println_i32 (. z 0);
        println_i32 (. z 1);
    };
    block {
        let (x:(i32 i32) (pair 900 901));
        println_i32 (dot x 0);
        println_i32 (dot x 1);
    };
    block {
        let (x:(i32 i32) (pair 1000 1001));
        let (y:((i32 i32) *) (& x));
        let (z:(i32 i32) (copy y));
        println_i32 (dot z 0);
        println_i32 (dot z 1);
    };
    block {
        = (. glob1 0) 1100;
        println_i32 (. glob1 0);
    };
    block {
        let (x:((i32 i32) cn) (pair 1200 1201));
        println_i32 (. x 0);
    };
    block {
        let x:(i32 i32);
        = (. x 0) 1300;
        println_i32 (* (& (. x 0)));
    };
    block {
        let x:(i32 i32);
        cast (i32 i32) x;
        cast ((i32 i32) cn) x;
    };
    block {
        let x:((i32 (i32 4)));
        = ([] (. x 1) 0) 1400;
        println_i32 ([] (. x 1) 0);
    };
    block {
        let (x:((i32 cn) (i32 cn)) (addCn (pair 1500 1501)));
        println_i32 (. x 0);
    };
    block {
        let (x:((i32 cn) (i32 cn)) (addCn (pair 1600 1601)));
        let (y:((i32 cn) (i32 cn)) x);
        println_i32 (. y 0);
    };
    block {
        let (x:((i32 cn) (i32 cn)) (addCn (pair 1700 1701)));
        let (y:(i32 i32) (remCn x));
        println_i32 (. y 0);
    };
    block {
        let x:(((i32 cn) bool) cn 4 cn *);
    };
    block {
        let (x:(i32 i32) (pair 0 0));
        let (y:((i32 cn) i32) (* (cast (((i32 cn) (i32)) *) (& x))));
        = (. y 1) 1800;
        println_i32 (. y 1);
    };
    block {
        let (x:(i32 i32) (1900:i32 1901:i32));
        println_i32 (. x 1);
    };
    block {
        let (x:((i32 cn) (i32 cn)) (2000:(i32 cn) 2001:(i32 cn)));
        println_i32 (. x 0);
    };
    block {
        println_i32 (. (2100:i32 2101:i32) 1);
    };
    block {
        println_i32 (dot (2200:i32 2201:i32) 0);
    };
    block {
        let (y:(i32 i32) (pair 2300 2300));
        let (x:((i32 i32) (i32 i32)) (y (2301:i32 2301:i32)));
        println_i32 (. (. x 0) 0);
        println_i32 (. x 1 0);
    };
    block {
        let x:((i32 i32) (i32 i32));
        = (. x 0 0) 2400;
        println_i32 (. x 0 0);
    };
};