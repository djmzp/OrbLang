import "tests/io.orb";

data Point {
    x:i32 y:i32 v:bool
}

data Node {
    val:i32 l:Node* r:Node*
}

data Tree {
    root:Node
}

data PtrI32Cn {
    p:i32 cn*
}

data ArrI32 {
    a:i32[4]
}

data Int {
    x:i32
}

data Fwd;

data WithFwd {
    o:Fwd*
}

data Fwd {
    u:u32
}

data Opaq;

fnc makePoint(i32 x, i32 y, bool v) Point {
    let p:Point;
    (= (. p x) x);
    (= (. p y) y);
    (= (. p v) v);
    ret p;
}

fnc makeNode(i32 val, Node* l, Node* r) Node {
    let n:Node;
    (= (. n val) val);
    (= (. n l) l);
    (= (. n r) r);
    ret n;
}

fnc sum(ArrI32 a) i32 {
    let (s:i32 0);
    for (let (i:i32 0); (< i 4); (++ i)) (+= s ([] (. a a) i));
    ret s;
}

fnc setAll(ArrI32* a, i32 t) {
    for (let (i:i32 0); (< i 4); (++ i)) (= ([] (. a a) i) t);
}

let glob1:Int;

fnc main() {
    {
        let z:Int;
        (= (. z x) 0);
        (println_i32 (. z x));
        let a:ArrI32;
        (= ([] (. a a) 1) 1);
        (println_i32 ([] (. a a) 1));
        (= (. glob1 x) 2);
        (println_i32 (. glob1 x));
    }
    {
        let p:Point;
        (= (. p x) 100);
        (= (. p y) 101);
        (println_i32 (. p x));
        (= (. p v) false);
        if ((. p v)) (println_i32 (. p y));
    }
    {
        let (p:Point cn (makePoint 200 201 true));
        (println_i32 (. p x));
        (println_i32 (* (& (. p y))));
    }
    {
        let p:Point[4];
        (= ([] p 2) (makePoint 300 301 false));
        (println_i32 (. ([] p 2) x));
    }
    {
        let a:ArrI32;
        (= ([] (. a a) 2) (. (makePoint 400 401 false) x));
        (println_i32 ([] (. a a) 2));
    }
    {
        (println_i32 (. (makePoint 500 501 true) x));
    }
    {
        let (n1:Node (makeNode 600 null null));
        (println_i32 (. n1 val));
        let (n2:Node (makeNode 601 null null));
        (= (. n1 l) (& n2));
        (println_i32 (. (* (. n1 l)) val));
    }
    {
        let t:Tree;
        (= (. t root) (makeNode 700 null null));
        (println_i32 (. (. t root) val));
    }
    {
        let o:Fwd;
        (= (. o u) 800);
        let w:WithFwd;
        (= (. w o) (& o));
        (println_u32 (. (. w o) u));
    }
    {
        let z1:Int[4];
        (= (. ([] z1 0) x) 0);
        let (z2:Int cn[4] z1);
        (println_i32 (+ 900 (. ([] z2 0) x)));
    }
    {
        let x:Int;
        (cast Int x);
        (cast Int cn x);
    }
    {
        let o1:Opaq*;
        let o2:Opaq**;
        (* o2);
    }
    {
        let a:ArrI32[4];
        (= ([] (. ([] a 0) a) 0) 1000);
        (println_i32 ([] (. ([] a 0) a) 0));
        (= ([] (. ([] a 0) a) 1) 1001);
        (println_i32 (* (& ([] (. ([] a 0) a) 1))));
    }
    {
        let a:ArrI32;
        (= ([] (. a a) 0) 1100);
        (= ([] (. a a) 1) (= ([] (. a a) 2) 1));
        (= ([] (. a a) 3) (- 2));
        (println_i32 (sum a));
        (setAll (& a) 1101);
        (println_i32 ([] (. a a) 1));
    }
    {
        let x:Int;
        (= (. (& x) x) 1200);
        (println_i32 (. (& x) x));
    }
}